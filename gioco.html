<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gioco</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <style>
        body {
    margin: 0;
    overflow: hidden;
    background-color: #3f3851;
    position: relative;
}

canvas {
    display: block;
    background-color: #3f3851;
}

#playerName {
    font-size: 32px;
    padding: 10px;
    border: 2px solid #ffffff;
    border-radius: 5px;
    color: #ffffff;
    background-color: #333333;
    position: absolute;
    z-index: 10;
}

#submitButton {
    font-size: 24px;
    color: #ffffff;
    background-color: #333333;
    padding: 10px 20px;
    border-radius: 5px;
    position: absolute;
    z-index: 10;
}

    </style>
</head>

<body>

    <script>
class Cat {
    constructor(scene) {
        this.scene = scene;
        this.gatto = null;
        this.lives = 3;
        this.coins = 0;
        this.livesText = null;
        this.coinsText = null;
        this.isAttacking = false;
        this.attackTimer = 0;

        this.DEFAULT_HITBOX = { width: 570, height: 480, offsetX: 240, offsetY: 720 };
        this.ATTACK_HITBOX = { width: 800, height: 600, offsetX: 260, offsetY: 600 };

        this.SPEED = 300;
        this.RUN_SPEED = 600;
        this.ATTACK_COOLDOWN = 500;
    }

    preload() {
        this.scene.load.spritesheet('gatto_idle', 'assets/gatto_fermo.png', { frameWidth: 1200, frameHeight: 1200 });
        this.scene.load.spritesheet('gatto_walk', 'assets/gatto_camminata.png', { frameWidth: 1200, frameHeight: 1200 });
        this.scene.load.spritesheet('gatto_run', 'assets/gatto_corsa.png', { frameWidth: 1200, frameHeight: 1200 });
        this.scene.load.spritesheet('gatto_attacco', 'assets/gatto_attacco.png', { frameWidth: 1200, frameHeight: 1200 });
        this.scene.load.spritesheet('coin', 'assets/coin.png', { frameWidth: 64, frameHeight: 64 });
    }

    create(x, y) {
        this.gatto = this.scene.physics.add.sprite(x, y, 'gatto_idle');
        this.gatto.setScale(0.13);
        this.setHitbox('default');
        this.gatto.body.setGravityY(300);
        this.gatto.setBounce(0.01);
        this.gatto.setCollideWorldBounds(true);

        this.scene.anims.create({ key: 'idle', frames: this.scene.anims.generateFrameNumbers('gatto_idle', { start: 0, end: 7 }), frameRate: 10, repeat: -1 });
        this.scene.anims.create({ key: 'walk', frames: this.scene.anims.generateFrameNumbers('gatto_walk', { start: 0, end: 7 }), frameRate: 10, repeat: -1 });
        this.scene.anims.create({ key: 'run', frames: this.scene.anims.generateFrameNumbers('gatto_run', { start: 0, end: 3 }), frameRate: 12, repeat: -1 });
        this.scene.anims.create({ key: 'attack', frames: this.scene.anims.generateFrameNumbers('gatto_attacco', { start: 0, end: 4 }), frameRate: 12, repeat: 0 });

        this.gatto.anims.play('idle');
        this.createUI();
    }

    createUI() {
        const createTextBackground = (x, y, width, height) => {
            const graphics = this.scene.add.graphics();
            graphics.fillStyle(0x3f3851, 0.9); // Colore nero con maggiore opacitÃ 
            graphics.fillRoundedRect(x, y, width, height, 5); // Angoli stondati
            return graphics;
        };

        this.livesBackground = createTextBackground(10, 10, 150, 50);
        this.coinsBackground = createTextBackground(10, 70, 265, 50); 

        this.livesText = this.scene.add.text(20, 20, 'Vite: 3', { fontSize: '32px', fill: '#fff' });
        this.coinsText = this.scene.add.text(20, 80, 'Monete: 0/25', { fontSize: '32px', fill: '#fff' });
    }

    setHitbox(type) {
        const hitbox = type === 'attack' ? this.ATTACK_HITBOX : this.DEFAULT_HITBOX;
        this.gatto.body.setSize(hitbox.width, hitbox.height);
        this.gatto.body.setOffset(this.gatto.flipX ? hitbox.offsetX + (type === 'attack' ? -150 : 150) : hitbox.offsetX, hitbox.offsetY);
    }

    update(cursors, keys) {
        if (this.isAttacking) {
            this.setHitbox('attack');
            this.gatto.anims.play('attack', true);
            this.gatto.setVelocityX(0);

            if (this.scene.time.now > this.attackTimer) {
                this.isAttacking = false;
                this.setHitbox('default');
                this.gatto.anims.play('idle', true);
            }
        } else {
            this.setHitbox('default');
            this.handleMovement(cursors, keys);
        }

        this.updateUI();
    }

    handleMovement(cursors, keys) {
        if (cursors.left.isDown || keys.left.isDown) {
            this.moveCat(-1, keys.shift.isDown);
        } else if (cursors.right.isDown || keys.right.isDown) {
            this.moveCat(1, keys.shift.isDown);
        } else {
            this.stopCat();
        }

        if (keys.jump.isDown && this.gatto.body.touching.down) {
            this.gatto.setVelocityY(-500);
        }

        if (keys.attack.isDown && !this.isAttacking && this.scene.time.now > this.attackTimer) {
            this.startAttack();
        }
    }

    moveCat(direction, isRunning) {
        const speed = isRunning ? this.RUN_SPEED : this.SPEED;
        this.gatto.setVelocityX(direction * speed);
        this.gatto.flipX = direction < 0;
        this.gatto.anims.play(isRunning ? 'run' : 'walk', true);
    }

    stopCat() {
        this.gatto.setVelocityX(0);
        if (this.gatto.anims.currentAnim.key !== 'idle') {
            this.gatto.anims.play('idle', true);
        }
    }

    startAttack() {
        this.isAttacking = true;
        this.attackTimer = this.scene.time.now + this.ATTACK_COOLDOWN;
        this.gatto.anims.play('attack', true);
    }

    updateUI() {
        if (this.livesText) {
            this.livesText.setText(`Vite: ${this.lives}`);
        }
        if (this.coinsText) {
            this.coinsText.setText(`Monete: ${this.coins}/25`);
        }
    }

    loseLife() {
        this.lives--;
        if (this.lives <= 0) {
            console.log('Game Over');
            this.scene.scene.start('MenuScene');
            window.location.reload();
        }
    }

    increaseLife() {
        this.lives++;
        if (this.livesText) {
            this.livesText.setText(`Vite: ${this.lives}`);
        }
    }

    collectCoin() {
        this.coins++;
    }
}

function createRectangularPlatforms(scene, platformsData) {
    const platforms = scene.add.group();
    platformsData.forEach(data => {
        const platform = scene.add.rectangle(data.x, data.y, data.width, data.height, data.color).setOrigin(0.5, 0.5);
        scene.physics.add.existing(platform, true);
        platforms.add(platform);
    });
    return platforms;
}

function createCoins(scene, coinsData) {
    const coins = scene.physics.add.group({
        key: 'coin',
        frameQuantity: coinsData.length,
        collideWorldBounds: true,
        immovable: false
    });
    coins.children.iterate((coin, index) => {
        const data = coinsData[index];
        coin.setPosition(data.x, data.y);
        coin.setScale(0.7);
        coin.setOrigin(0.5, 0.5);
        coin.setSize(64, 64);
        coin.setOffset(0, 0);
        scene.anims.create({
            key: 'spin',
            frames: scene.anims.generateFrameNumbers('coin', { start: 0, end: 13 }),
            frameRate: 24,
            repeat: -1
        });
        coin.anims.play('spin');
    });
    return coins;
}





        function createRectangularPlatforms(scene, platformsData) {
            const platforms = scene.add.group();
            platformsData.forEach(data => {
                const platform = scene.add.rectangle(data.x, data.y, data.width, data.height, data.color).setOrigin(0.5, 0.5);
                scene.physics.add.existing(platform, true);
                platforms.add(platform);
            });
            return platforms;
        }

        function createCoins(scene, coinsData) {
            const coins = scene.physics.add.group({
                key: 'coin',
                frameQuantity: coinsData.length,
                collideWorldBounds: true,
                immovable: false
            });
            coins.children.iterate((coin, index) => {
                const data = coinsData[index];
                coin.setPosition(data.x, data.y);
                coin.setScale(0.7);
                coin.setOrigin(0.5, 0.5);
                coin.setSize(64, 64);
                coin.setOffset(0, 0);
                scene.anims.create({
                    key: 'spin',
                    frames: scene.anims.generateFrameNumbers('coin', { start: 0, end: 13 }),
                    frameRate: 24,
                    repeat: -1
                });
                coin.anims.play('spin');
            });
            return coins;
        }
        
        class MenuScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MenuScene' });
    }
    preload() {
        this.load.image('button', 'assets/play01.png');
    }
    create() {
        this.cameras.main.setBackgroundColor('#2a2536');
        const { width: gameWidth, height: gameHeight } = this.scale;
        const title = this.add.text(gameWidth / 2, gameHeight / 4, 'Menu Principale', {
            fontSize: `${gameHeight / 10}px`,
            color: '#ffffff',
            fontFamily: '"Press Start 2P", Arial',
            stroke: '#000000',
            strokeThickness: 8,
            shadow: {
                offsetX: 6,
                offsetY: 6,
                color: '#000',
                blur: 8,
                stroke: true,
                fill: true
            }
        }).setOrigin(0.5);
        this.playButton = this.add.image(gameWidth / 2, gameHeight / 2, 'button')
            .setScale(0.5)
            .setInteractive();
        this.playButton.on('pointerover', () => {
            this.playButton.setScale(0.55);
        });
        this.playButton.on('pointerout', () => {
            this.playButton.setScale(0.5);
        });
        this.playButton.on('pointerdown', () => {
            this.showInputField();
        });
        this.inputField = null;
        this.submitButton = null;
    }
    showInputField() {
        if (this.inputField) {
            return;
        }
        this.inputField = this.add.dom(this.scale.width / 2, this.scale.height / 2 + 100, 'input', {
            type: 'text',
            id: 'playerName',
            name: 'name',
            placeholder: 'Inserisci il tuo nome (opzionale)',
            style: `
                font-size: 32px; 
                padding: 10px; 
                border: 2px solid #ffffff; 
                border-radius: 5px; 
                color: #ffffff; 
                background-color: #333333; 
                width: 200px;
                `
        }).setOrigin(0.5);
        this.submitButton = this.add.text(this.scale.width / 2, this.scale.height / 2 + 200, 'Conferma', {
            fontSize: '24px',
            color: '#ffffff',
            backgroundColor: '#333333',
            padding: { x: 20, y: 10 },
            borderRadius: 5
        }).setOrigin(0.5).setInteractive();

        this.submitButton.on('pointerdown', () => {
            this.handleNameSubmission();
        });
    }
    handleNameSubmission() {
        const playerNameInput = document.getElementById('playerName');
        const defaultNames = ['Giocatore1', 'Giocatore2', 'Giocatore3'];
        let playerName;
        if (playerNameInput) {
            playerName = playerNameInput.value.trim();
        }
        if (!playerName) {
            playerName = this.getRandomDefaultName(defaultNames);
        }
        this.game.playerName = playerName;
        if (!this.game.globalTime) {
            this.game.globalTime = 0;
            this.game.timeEvent = this.time.addEvent({
                delay: 1000,
                callback: () => {
                    this.game.globalTime++;
                },
                loop: true
            });
        }
        if (this.inputField) {
            this.inputField.destroy();
            this.inputField = null;
        }
        if (this.submitButton) {
            this.submitButton.destroy();
            this.submitButton = null;
        }
        this.cameras.main.fadeOut(500, 0, 0, 0);
        this.time.delayedCall(500, () => {
            this.scene.start('Scene1');
        });
    }
    getRandomDefaultName(names) {
        return names[Math.floor(Math.random() * names.length)];
    }
}

class Scene1 extends Phaser.Scene {
    constructor() {
        super({ key: 'Scene1' });
        this.cat = new Cat(this);
        this.coinPositions = [
            { x: 800, y: 300 }, { x: 1100, y: 300 }, { x: 1300, y: 700 },
            { x: 900, y: 160 }, { x: 1370, y: 200 }, { x: 1000, y: 600 },
            { x: 1190, y: 500 }, { x: 550, y: 300 }, { x: 700, y: 800 },
            { x: 1450, y: 700 }
        ];
        this.startingPosition = { x: 932, y: 600 };
        this.currentCoins = 0;
        this.bonusSpawnInterval = Phaser.Math.Between(7, 20);
        this.usedCoinPositions = [];
        this.enemyData = [
            { x: 1013, y: 160, leftBound: 750, rightBound: 1180, speed: 100 },
            { x: 750, y: 400, leftBound: 625, rightBound: 790, speed: 80 },
            { x: 1000, y: 350, leftBound: 1000, rightBound: 1180, speed: 110 },
            { x: 700, y: 800, leftBound: 640, rightBound: 800, speed: 90 },
            { x: 1250, y: 550, leftBound: 1250, rightBound: 1360, speed: 75 }
        ];
        this.enemies = [];
        this.enemyAttackDelay = 2000;
        this.lastEnemyAttackTime = 0;
    }

    preload() {
        this.cat.preload();
        this.load.image('mappa_1', 'assets/mappa_1.png');
        this.load.image('bonus', 'assets/Healthpotion.png');
        this.load.image('coin', 'assets/coin.png');
        this.load.audio('coin_sound', 'assets/suono_raccolta_moneta_2.mp3');
        this.load.audio('25coin_sound', 'assets/suono_raccolta_moneta_1.mp3');
        this.load.audio('damage_sound', 'assets/suono_acqua.mp3');
        this.load.audio('bonus_sound', 'assets/potion_sound.mp3');
        this.load.audio('background_music', 'assets/backround_music.mp3');
        this.load.spritesheet('enemy', 'assets/slime1_move.png', { frameWidth: 42, frameHeight: 36 });
        this.load.spritesheet('enemy_die', 'assets/slime1_die.png', { frameWidth: 66, frameHeight: 36 });
    }

    create() {

        startGlobalTimer(this); 

        this.add.image(this.scale.width / 2, this.scale.height / 2, 'mappa_1');
        this.cat.create(this.startingPosition.x, this.startingPosition.y);
        this.anims.create({
            key: 'slime_move',
            frames: this.anims.generateFrameNumbers('enemy', { start: 0, end: 6 }),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'slime_die',
            frames: this.anims.generateFrameNumbers('enemy_die', { start: 0, end: 12 }),
            frameRate: 10,
            repeat: 0
        });
        this.platforms = createRectangularPlatforms(this, [
            { x: 992, y: 32, width: 960, height: 64 }, { x: 1440, y: 320, width: 64, height: 512 },
            { x: 544, y: 160, width: 64, height: 192 }, { x: 480, y: 288, width: 64, height: 192 },
            { x: 544, y: 448, width: 64, height: 256 }, { x: 480, y: 672, width: 64, height: 320 },
            { x: 1504, y: 672, width: 64, height: 320 }, { x: 544, y: 832, width: 64, height: 128 },
            { x: 1440, y: 832, width: 64, height: 128 }, { x: 704, y: 960, width: 384, height: 128 },
            { x: 1280, y: 960, width: 384, height: 128 }, { x: 960, y: 224, width: 512, height: 64 },
            { x: 1376, y: 288, width: 64, height: 64 }, { x: 1088, y: 416, width: 256, height: 64 },
            { x: 704, y: 480, width: 256, height: 64 }, { x: 1344, y: 608, width: 256, height: 64 },
            { x: 928, y: 736, width: 448, height: 64 }
        ]);
        this.dangerousPlatforms = createRectangularPlatforms(this, [
            { x: 992, y: 994, width: 192, height: 60 }
        ]);
        this.backgroundMusic = this.sound.add('background_music');
        this.backgroundMusic.setVolume(0.05);
        this.backgroundMusic.play({ loop: true });
        this.coins = this.physics.add.group({
            key: 'coin',
            frameQuantity: 0,
            collideWorldBounds: true,
            immovable: false
        });

        this.showNextCoin();
        this.physics.add.collider(this.cat.gatto, this.platforms);
        this.physics.add.collider(this.coins, this.platforms);
        this.physics.add.collider(this.cat.gatto, this.dangerousPlatforms, this.handleDangerousPlatformCollision, null, this);
        this.physics.add.overlap(this.cat.gatto, this.coins, (cat, coin) => {
            coin.destroy();
            this.coins.remove(coin);
            this.cat.collectCoin();
            this.currentCoins++;
            if (this.currentCoins % this.bonusSpawnInterval === 0) {
                this.showBonus();
            }
            if (this.currentCoins < 25) {
                this.showNextCoin();
            } else {
                this.sound.play('25coin_sound');
                this.scene.start('Scene2');
            }
            this.sound.play('coin_sound');
        });
        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = {
            left: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
            right: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
            shift: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT),
            jump: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
            attack: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E)
        };

        this.createEnemies();
    }

    createEnemies() {
        this.enemyData.forEach(data => {
            const enemy = this.physics.add.sprite(data.x, data.y, 'enemy');
            enemy.setScale(1.5);
            enemy.anims.play('slime_move');
            enemy.leftBound = data.leftBound;
            enemy.rightBound = data.rightBound;
            enemy.speed = data.speed;
            this.enemies.push(enemy);
            this.physics.add.collider(enemy, this.platforms);
        });
    }
    update() {
        const now = this.time.now;
        this.cat.update(this.cursors, this.keys);
        this.enemies.forEach(enemy => {
            if (!enemy) return;
            if (enemy.x <= enemy.leftBound) {
                enemy.speed = Math.abs(enemy.speed);
                enemy.setFlipX(false);
            } else if (enemy.x >= enemy.rightBound) {
                enemy.speed = -Math.abs(enemy.speed);
                enemy.setFlipX(true);
            }
            enemy.setVelocityX(enemy.speed);
            if (this.keys.attack.isDown && !this.cat.isAttacking) {
                if (this.physics.overlap(this.cat.gatto, enemy)) {
                    this.handleEnemyDeath(enemy);
                }
            }
            if (!this.cat.isAttacking && this.physics.overlap(this.cat.gatto, enemy)) {
                if (now - this.lastEnemyAttackTime > this.enemyAttackDelay) {
                    this.cat.loseLife();
                    this.cat.gatto.setPosition(this.startingPosition.x, this.startingPosition.y);
                    this.lastEnemyAttackTime = now;
                }
            }
        });
    }
    showNextCoin() {
        if (this.currentCoins >= 25) return;
        let availablePositions = this.coinPositions.filter(pos => !this.usedCoinPositions.includes(pos));
        if (availablePositions.length === 0) return;

        const randomIndex = Phaser.Math.Between(0, availablePositions.length - 1);
        const { x, y } = availablePositions[randomIndex];

        const coin = this.coins.create(x, y, 'coin');
        coin.setScale(0.7);
        coin.setOrigin(0.5, 0.5);
        coin.setSize(64, 64);
        coin.setOffset(0, 0);

        this.usedCoinPositions.push({ x, y });

        this.anims.create({
            key: 'spin',
            frames: this.anims.generateFrameNumbers('coin', { start: 0, end: 13 }),
            frameRate: 24,
            repeat: -1
        });
        coin.anims.play('spin');
    }

    showBonus() {
        if (this.bonus) {
            this.bonus.destroy();
        }

        if (this.usedCoinPositions.length === 0) return;

        const randomIndex = Phaser.Math.Between(0, this.usedCoinPositions.length - 1);
        const { x, y } = this.usedCoinPositions[randomIndex];

        this.bonus = this.physics.add.sprite(x, y, 'bonus');
        this.bonus.setScale(1.4);
        this.bonus.setSize(20, 25);
        this.bonus.setOffset(0, 0);
        this.physics.add.collider(this.bonus, this.platforms);
        this.physics.add.overlap(this.cat.gatto, this.bonus, this.collectBonus, null, this);
    }

    handleDangerousPlatformCollision(cat, platform) {
        this.sound.play('damage_sound');
        this.cat.loseLife();
        this.cat.gatto.setPosition(this.startingPosition.x, this.startingPosition.y);
    }

    collectBonus(cat, bonus) {
        this.sound.play('bonus_sound');
        this.cat.increaseLife();
        bonus.disableBody(true, true);
    }

    handleEnemyDeath(enemy) {
        if (enemy) {
            enemy.anims.play('slime_die', true);
            enemy.disableBody();
            enemy.setVelocityX(0);
            this.time.delayedCall(1000, () => {
                if (enemy) {
                    enemy.destroy();
                    this.enemies = this.enemies.filter(e => e !== enemy);
                }
            });
        }
    }
}

class Scene2 extends Phaser.Scene {
    constructor() {
        super({ key: 'Scene2' });
        this.cat = new Cat(this);
        this.coinPositions = [
            { x: 800, y: 800 }, { x: 600, y: 280 }, { x: 1500, y: 480 },
            { x: 700, y: 150 }, { x: 400, y: 800 }, { x: 1200, y: 780 },
            { x: 800, y: 680 }, { x: 1100, y: 280 }, { x: 1750, y: 480 },
            { x: 1550, y: 680 }
        ];
        this.startingPosition = { x: 620, y: 300 }; 
        this.currentCoins = 0; 
        this.bonusSpawnInterval = Phaser.Math.Between(7, 20); 
        this.enemyData = [ 
            { x: 600, y: 540, leftBound: 580, rightBound: 720, speed: 100 },
            { x: 1200, y: 780, leftBound: 1070, rightBound: 1300, speed: 80 },
            { x: 1550, y: 550, leftBound: 1350, rightBound: 1550, speed: 90 },
            { x: 680, y: 150, leftBound: 650, rightBound: 980, speed: 110 },
            { x: 1550, y: 200, leftBound: 1400, rightBound: 1550, speed: 75 },
            { x: 480, y: 760, leftBound: 370, rightBound: 480, speed: 65 }
        ];
        this.enemies = [];
    }

    preload() {
        this.cat.preload();
        this.load.image('mappa_2', 'assets/mappa_2.png');
        this.load.spritesheet('coin', 'assets/coin_spritesheet.png', { frameWidth: 32, frameHeight: 32 });
        this.load.image('bonus', 'assets/Healthpotion.png');
        this.load.audio('coin_sound', 'assets/suono_raccolta_moneta_2.mp3');
        this.load.audio('25coin_sound', 'assets/suono_raccolta_moneta_1.mp3');
        this.load.audio('damage_sound', 'assets/suono_acqua.mp3');
        this.load.audio('bonus_sound', 'assets/potion_sound.mp3');
        // this.load.audio('background_music', 'assets/background_music.mp3');
        this.load.spritesheet('enemy2', 'assets/slime2_move.png', { frameWidth: 42, frameHeight: 36 });
        this.load.spritesheet('enemy2_die', 'assets/slime2_die.png', { frameWidth: 66, frameHeight: 36 });
    }

    create() {
        this.add.image(this.scale.width / 2, this.scale.height / 2, 'mappa_2');
        this.cat.create(this.startingPosition.x, this.startingPosition.y);

        // this.backgroundMusic = this.sound.add('background_music');
        // this.backgroundMusic.setVolume(0.05);
        // this.backgroundMusic.play({ loop: true });
        this.platforms = createRectangularPlatforms(this, [
            { x: 1088, y: 32, width: 1280, height: 64 },
            { x: 480, y: 96, width: 64, height: 64 },
            { x: 1600, y: 96, width: 128, height: 64 },
            { x: 1632, y: 160, width: 64, height: 64 },
            { x: 1696, y: 256, width: 64, height: 384 },
            { x: 1760, y: 416, width: 64, height: 64 },
            { x: 1824, y: 544, width: 64, height: 320 },
            { x: 1760, y: 672, width: 64, height: 64 },
            { x: 1696, y: 736, width: 64, height: 192 },
            { x: 1760, y: 896, width: 64, height: 256 },
            { x: 416, y: 160, width: 64, height: 320 },
            { x: 352, y: 352, width: 64, height: 192 },
            { x: 416, y: 576, width: 64, height: 384 },
            { x: 352, y: 736, width: 64, height: 64 },
            { x: 288, y: 832, width: 64, height: 256 },
            { x: 416, y: 928, width: 192, height: 64 },
            { x: 480, y: 992, width: 64, height: 64 },
            { x: 800, y: 224, width: 448, height: 64 },
            { x: 608, y: 416, width: 64, height: 64 },
            { x: 1472, y: 288, width: 256, height: 64 },
            { x: 1056, y: 416, width: 320, height: 64 },
            { x: 640, y: 672, width: 256, height: 64 },
            { x: 992, y: 736, width: 192, height: 64 },
            { x: 1440, y: 608, width: 320, height: 64 },
            { x: 1504, y: 800, width: 192, height: 64 },
            { x: 736, y: 864, width: 192, height: 64 },
            { x: 1184, y: 864, width: 320, height: 64 }
        ]);
        this.dangerousPlatforms = createRectangularPlatforms(this, [
            { x: 1120, y: 994, width: 1216, height: 60 }
        ]);
        this.anims.create({
            key: 'slime2_move',
            frames: this.anims.generateFrameNumbers('enemy2', { start: 0, end: 6 }),
            frameRate: 10,
            repeat: -1
        });
        this.anims.create({
            key: 'slime2_die',
            frames: this.anims.generateFrameNumbers('enemy2_die', { start: 0, end: 12 }),
            frameRate: 10,
            repeat: 0
        });
        this.coins = this.physics.add.group({
            key: 'coin',
            frameQuantity: 0, 
            collideWorldBounds: true,
            immovable: false
        });
        this.bonus = null; 
        this.showNextCoin();

        this.physics.add.collider(this.cat.gatto, this.platforms);
        this.physics.add.collider(this.coins, this.platforms);
        this.physics.add.collider(this.cat.gatto, this.dangerousPlatforms, this.handleDangerousPlatformCollision, null, this);
        this.physics.add.overlap(this.cat.gatto, this.coins, (cat, coin) => {
            coin.destroy();
            this.coins.remove(coin);
            this.cat.collectCoin();
            this.currentCoins++;
            if (this.currentCoins % this.bonusSpawnInterval === 0) {
                this.showBonus(); 
            }
            if (this.currentCoins < 25) {
                this.showNextCoin(); 
            } else {
                this.sound.play('25coin_sound');
                this.scene.start('Scene3');
            }
            this.sound.play('coin_sound');
        });
        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = {
            left: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
            right: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
            shift: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT),
            jump: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
            attack: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E)
        };
        this.createEnemies();
    }

    createEnemies() {
        this.enemyData.forEach(data => {
            const enemy = this.physics.add.sprite(data.x, data.y, 'enemy2');
            enemy.setScale(1.5);
            enemy.anims.play('slime2_move');
            enemy.leftBound = data.leftBound;
            enemy.rightBound = data.rightBound;
            enemy.speed = data.speed;
            this.enemies.push(enemy);
            this.physics.add.collider(enemy, this.platforms);
        });
    }

    update() {
        this.cat.update(this.cursors, this.keys);
        this.enemies.forEach(enemy => {
            if (!enemy) return; 

            if (enemy.x <= enemy.leftBound) {
                enemy.speed = Math.abs(enemy.speed); 
                enemy.setFlipX(false); 
            } else if (enemy.x >= enemy.rightBound) {
                enemy.speed = -Math.abs(enemy.speed); 
                enemy.setFlipX(true); 
            }
            enemy.setVelocityX(enemy.speed);

            if (this.keys.attack.isDown && !this.cat.isAttacking) {
                if (this.physics.overlap(this.cat.gatto, enemy)) {
                    this.handleEnemyDeath(enemy);
                }
            }

            if (!this.cat.isAttacking && this.physics.overlap(this.cat.gatto, enemy)) {
                this.cat.loseLife(); 
                this.cat.gatto.setPosition(this.startingPosition.x, this.startingPosition.y); 
            }
        });
    }

    showNextCoin() {
        if (this.currentCoins >= 25) return; 
        const randomIndex = Phaser.Math.Between(0, this.coinPositions.length - 1);
        const { x, y } = this.coinPositions[randomIndex];

        const coin = this.coins.create(x, y, 'coin');
        coin.setScale(0.7);
        coin.setOrigin(0.5, 0.5);
        coin.setSize(64, 64);
        coin.setOffset(0, 0);

        console.log('Moneta creata:', { x, y });

        this.anims.create({
            key: 'spin',
            frames: this.anims.generateFrameNumbers('coin', { start: 0, end: 13 }),
            frameRate: 24,
            repeat: -1
        });
        coin.anims.play('spin');
    }

    showBonus() {
        if (this.bonus) {
            this.bonus.destroy();
        }
        let positionFound = false;
        let position = { x: 0, y: 0 };
        const maxAttempts = 10;
        let attempts = 0;

        while (!positionFound && attempts < maxAttempts) {
            const randomIndex = Phaser.Math.Between(0, this.coinPositions.length - 1);
            position = this.coinPositions[randomIndex];

            // Verifica se la posizione Ã¨ libera
            const coinAtPosition = this.coins.getChildren().some(coin => {
                return Phaser.Geom.Intersects.RectangleToRectangle(
                    new Phaser.Geom.Rectangle(position.x, position.y, 64, 64),
                    new Phaser.Geom.Rectangle(coin.x - 32, coin.y - 32, 64, 64)
                );
            });

            if (!coinAtPosition) {
                positionFound = true;
            } else {
                attempts++;
            }
        }

        if (!positionFound) {
            console.log('Nessuna posizione libera trovata per il bonus.');
            return;
        }
        this.bonus = this.physics.add.sprite(position.x, position.y, 'bonus');
        this.bonus.setScale(1.4);
        this.bonus.setSize(20, 25);
        this.bonus.setOffset(0, 0); 
        this.physics.add.collider(this.bonus, this.platforms);
        this.physics.add.overlap(this.cat.gatto, this.bonus, this.collectBonus, null, this);

        console.log('Bonus creato nella posizione:', position);
    }

    handleDangerousPlatformCollision(cat, platform) {
        this.sound.play('damage_sound');
        this.cat.loseLife(); 
        this.cat.gatto.setPosition(this.startingPosition.x, this.startingPosition.y);
    }

    collectBonus(cat, bonus) {
        this.sound.play('bonus_sound');
        this.cat.increaseLife();
        bonus.disableBody(true, true); 
    }

    handleEnemyDeath(enemy) {
        if (enemy) {
            enemy.anims.play('slime2_die', true);
            enemy.disableBody();
            enemy.setVelocityX(0); 
            this.time.delayedCall(1000, () => {
                if (enemy) {
                    enemy.destroy(); 
                    this.enemies = this.enemies.filter(e => e !== enemy); 
                }
            });
        }
    }
}



class Scene3 extends Phaser.Scene {
    constructor() {
        super({ key: 'Scene3' });
        this.cat = new Cat(this);
        this.coinPositions = [
            { x: 600, y: 600 }, { x: 800, y: 400 }, { x: 1200, y: 300 },
            { x: 1400, y: 500 }, { x: 880, y: 700 }, { x: 950, y: 200 },
            { x: 500, y: 300 }, { x: 500, y: 700 }
        ];
        this.startingPosition = { x: 500, y: 700 };
        this.currentCoins = 0;
        this.bonusSpawnInterval = Phaser.Math.Between(7, 20);
        this.bombsSpawned = 0;
    }

    preload() {
        this.cat.preload();
        this.load.image('mappa_3', 'assets/mappa_3.png');
        this.load.spritesheet('coin', 'assets/coin_spritesheet.png', { frameWidth: 32, frameHeight: 32 });
        this.load.image('bomb', 'assets/bomb.png');
        this.load.audio('coin_sound', 'assets/suono_raccolta_moneta_2.mp3');
        this.load.audio('25coin_sound', 'assets/suono_raccolta_moneta_1.mp3');
        this.load.audio('damage_sound', 'assets/suono_acqua.mp3');
        this.load.audio('background_music', 'assets/backround_music.mp3');
    }

    create() {
        this.createBackground();
        this.createCat();
        this.createMusic();
        this.createPlatforms();
        this.createCoins();
        this.createBombs();
        this.createCollisions();
        this.createControls();
    }

    update() {
        this.cat.update(this.cursors, this.keys);
    }

    // Helper Methods
    createBackground() {
        this.add.image(this.scale.width / 2, this.scale.height / 2, 'mappa_3');
    }

    createCat() {
        this.cat.create(this.startingPosition.x, this.startingPosition.y);
    }

    createMusic() {
        this.backgroundMusic = this.sound.add('background_music');
        this.backgroundMusic.setVolume(0.05);
        this.backgroundMusic.play({ loop: true });
    }

    createPlatforms() {
        this.platforms = createRectangularPlatforms(this, [
            { x: 928, y: 32, width: 704, height: 64 }, { x: 608, y: 96, width: 64, height: 64 },
            { x: 1248, y: 96, width: 64, height: 64 }, { x: 512, y: 160, width: 256, height: 64 },
            { x: 1344, y: 160, width: 256, height: 64 }, { x: 416, y: 352, width: 64, height: 320 },
            { x: 1440, y: 320, width: 64, height: 256 }, { x: 1504, y: 416, width: 64, height: 64 },
            { x: 1568, y: 576, width: 64, height: 384 }, { x: 1376, y: 738, width: 320, height: 64 },
            { x: 1184, y: 800, width: 64, height: 64 }, { x: 1120, y: 896, width: 64, height: 256 },
            { x: 864, y: 896, width: 64, height: 256 }, { x: 800, y: 800, width: 64, height: 64 },
            { x: 576, y: 864, width: 512, height: 64 }, { x: 352, y: 704, width: 64, height: 256 },
            { x: 416, y: 608, width: 64, height: 64 }, { x: 480, y: 544, width: 64, height: 192 },
            { x: 544, y: 416, width: 192, height: 64 }, { x: 992, y: 352, width: 320, height: 64 },
            { x: 800, y: 544, width: 192, height: 64 }, { x: 1216, y: 544, width: 256, height: 64 },
            { x: 992, y: 736, width: 48, height: 64 }, { x: 992, y: 1009, width: 192, height: 30 }
        ]);
        this.dangerousPlatforms = createRectangularPlatforms(this, [
            { x: 992, y: 994, width: 192, height: 60 }
        ]);
    }

    createCoins() {
        this.coins = this.physics.add.group({
            key: 'coin',
            frameQuantity: 0,
            collideWorldBounds: true
        });
        this.showNextCoin();
    }

    createBombs() {
        this.bombs = this.physics.add.group({
            key: 'bomb',
            frameQuantity: 0,
            collideWorldBounds: true
        });
    }

    createCollisions() {
        this.physics.add.collider(this.cat.gatto, this.platforms);
        this.physics.add.collider(this.coins, this.platforms);
        this.physics.add.collider(this.bombs, this.platforms);
        this.physics.add.collider(this.cat.gatto, this.dangerousPlatforms, this.handleDangerousPlatformCollision, null, this);
        this.physics.add.overlap(this.cat.gatto, this.coins, this.collectCoin, null, this);
        this.physics.add.overlap(this.cat.gatto, this.bombs, this.handleBombCollision, null, this);
    }

    createControls() {
        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = {
            left: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
            right: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
            shift: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT),
            jump: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
            attack: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E)
        };
    }

    showNextCoin() {
        if (this.currentCoins >= 25) return;

        const { x, y } = Phaser.Math.RND.pick(this.coinPositions);
        const coin = this.coins.create(x, y, 'coin');
        coin.setScale(0.7).setOrigin(0.5, 0.5).setSize(64, 64).setOffset(0, 0);

        this.anims.create({
            key: 'spin',
            frames: this.anims.generateFrameNumbers('coin', { start: 0, end: 13 }),
            frameRate: 24,
            repeat: -1
        });
        coin.anims.play('spin');
    }

    collectCoin(cat, coin) {
        coin.destroy();
        this.coins.remove(coin);
        this.cat.collectCoin();
        this.currentCoins++;

        if (this.currentCoins % 5 === 0) {
            this.spawnBomb(); 
        }

        if (this.currentCoins < 25) {
            this.showNextCoin();
        } else {
            this.sound.play('25coin_sound');
            this.scene.start('Scene4');
        }
        this.sound.play('coin_sound');
    }

    handleDangerousPlatformCollision(cat, platform) {
        this.sound.play('damage_sound');
        this.cat.loseLife();
        this.cat.gatto.setPosition(this.startingPosition.x, this.startingPosition.y);
    }

    spawnBomb() {
        const { x, y } = Phaser.Math.RND.pick(this.coinPositions);
        const bomb = this.bombs.create(x, y, 'bomb');
        bomb.setVelocityX(Phaser.Math.Between(-150, 150))
            .setVelocityY(Phaser.Math.Between(-150, 150))
            .setBounce(1.001)
            .setCollideWorldBounds(true);
        this.bombsSpawned++;
    }

    handleBombCollision(cat, bomb) {
        this.cat.loseLife();
        bomb.destroy();
    }
}



class Scene4 extends Phaser.Scene {
    constructor() {
        super({ key: 'Scene4' });
        this.cat = new Cat(this);

        // Load leaderboard on initialization
        this.leaderboard = this.loadLeaderboard();
    }

    preload() {
        this.cat.preload();
        this.load.image('mappa_4', 'assets/mappa_4.png');
        this.load.audio('coin_sound', 'assets/suono_raccolta_moneta_2.mp3');
        this.load.audio('25coin_sound', 'assets/suono_raccolta_moneta_1.mp3');
    }

    create() {
        this.add.image(this.scale.width / 2, this.scale.height / 2, 'mappa_4');
        this.cat.create(300, 300);

        this.platforms = createRectangularPlatforms(this, [
            { x: 64, y: 512, width: 128, height: 1024 },
            { x: 992, y: 64, width: 1984, height: 128 },
            { x: 1920, y: 512, width: 128, height: 1024 },
            { x: 992, y: 960, width: 1984, height: 128 },
        ]);

        this.physics.add.collider(this.cat.gatto, this.platforms);

        // Update leaderboard with the global timer value
        this.updateLeaderboard(game.global.timer);

        // Show the leaderboard on screen
        this.showLeaderboard();

        // Move to Scene1 when Enter is pressed
        this.input.keyboard.on('keydown-ENTER', () => {
            this.scene.start('Scene1');
        });

        // Setup keyboard controls for the cat
        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = {
            left: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
            right: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
            shift: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT),
            jump: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
            attack: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E)
        };

        // Clear coins text if it exists
        if (this.coinsText) {
            this.coinsText.destroy();
        }
    }

    update() {
        this.cat.update(this.cursors, this.keys);
    }

    updateLeaderboard(currentTime) {
        // Add the new time to the leaderboard
        this.leaderboard.push(currentTime);

        // Sort the leaderboard in ascending order
        this.leaderboard.sort((a, b) => a - b);

        // Keep only the top 6 times
        if (this.leaderboard.length > 6) {
            this.leaderboard.pop();
        }

        // Save the updated leaderboard
        this.saveLeaderboard();
    }

    showLeaderboard() {
        const { width: gameWidth, height: gameHeight } = this.scale;

        // Title of the leaderboard
        const titleText = this.add.text(gameWidth / 2, gameHeight / 4, 'Classifica dei Tempi', {
            fontSize: '48px',
            fill: '#ffffff',
            fontFamily: '"Press Start 2P", Arial',
            stroke: '#000000',
            strokeThickness: 6,
            align: 'center'
        }).setOrigin(0.5);

        // Display the leaderboard
        for (let i = 0; i < this.leaderboard.length; i++) {
            const timeText = this.add.text(gameWidth / 2, gameHeight / 4 + 100 + i * 50, 
                `${i + 1}. Tempo: ${this.leaderboard[i]} secondi`, {
                fontSize: '32px',
                fill: '#ffffff',
                fontFamily: '"Press Start 2P", Arial',
                stroke: '#000000',
                strokeThickness: 4,
                align: 'center'
            }).setOrigin(0.5);
        }
    }

    loadLeaderboard() {
        // Retrieve leaderboard from localStorage
        const storedData = localStorage.getItem('leaderboard');
        return storedData ? JSON.parse(storedData) : [];
    }

    saveLeaderboard() {
        // Save leaderboard to localStorage
        localStorage.setItem('leaderboard', JSON.stringify(this.leaderboard));
    }
}

        const config = {
            type: Phaser.AUTO,
            width: 1984,
            height: 1024,
            scene: [ Scene2, MenuScene, Scene1, Scene3, Scene4], 
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 300 },
                    debug: false
                }
            },
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };
        const game = new Phaser.Game(config);

        game.global = {
    timer: 0,
    startTime: Date.now(),
    timerEvent: null
};

function startGlobalTimer(scene) {
    if (!game.global.timerEvent) {
        game.global.timerEvent = scene.time.addEvent({
            delay: 1000,
            callback: () => {
                const now = Date.now();
                game.global.timer = Math.floor((now - game.global.startTime) / 1000);
                console.log(`Tempo: ${game.global.timer} secondi`);
            },
            loop: true
        });
    }
}

    </script>

</body>

</html>